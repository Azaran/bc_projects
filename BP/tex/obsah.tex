%=========================================================================
\chapter{Úvod}
Ochrana a~zabezpeèení soukromých a~dùle¾itých informací je v~dne¹ní dobì èasto se vyskytujícím
tématem na poli informaèních technologií. A» u¾ se bavíme o~zabezpeèení dat pøi pøenosu po síti
nebo o~zabezpeèení lokálnì ulo¾ených dat. Doká¾eme si asi pøedstavit situaci, kdy potøebujeme
sdílet informace, ale chceme zajistit, ¾e je budou schopny pøeèíst pouze osoby, které jsou k~tomu
urèeny.

 Vý¹e uvedeného lze dosáhnout ¹ifrováním informací. V~dne¹ní dobì existuje nespoèet mo¾ností, jak
informace ¹ifrovat. Kvalitu zabezpeèení dat znaènì ovlivòuje výbìr pou¾itého ¹ifrovacího
algoritmu a~dostateènì silného hesla. Pokud pou¾ijeme slabou ¹ifru a~silné heslo, je
¹ance, ¾e se k~Na¹im datùm dostane neoprávnìná osoba je výraznì ni¾¹í, ne¾ kdy¾ to udìláte naopak.

 Èasto chceme sdílet nebo zabezpeèit více ne¾ jeden soubor s~informacemi. Obecnì se pro
spojení více souborù rùzného typu do jednoho celku pou¾ívají archivy. Jedním z~nejroz¹íøenìj¹ích
typù souborových archivù jsou formáty .ZIP a~.7z.

 Tato práce se pøevá¾nì zabývá analýzou pou¾ívaných metod zabezpeèení a~¹ifrovacích
algoritmù u~tìchto formátù a~následnì získáváním hesel k~takto zabezpeèeným souborùm. Výsledky
analýz jsou pou¾ity pro návrh roz¹iøujících modulù nástroje {\it Wrathion}. Práce se také
zabývá pøiblí¾ením paralelismu a~problémù s~ním spojených. Jsou zde také popsány základní
principy a~struktury standardu a~frameworku OpenCL.

 V~kapitole \ref{ch:sifrovani} s~podíváme na ¹ifrovací a~he¹ovací metody pou¾ívané formáty
archivù. V~kapitole \ref{ch:opencl} si pøiblí¾eme technologii OpenCL, která je pou¾ita pro
akceleraci pomocí grafické karty v~nástroji {\it Wrathion}. Ten je popsán v~kapitole
\ref{ch:wrathion}. V~kapitole \ref{ch:formaty} jsou zanalyzovány formáty .ZIP a~.7z. Na základì
poznatkù z~analýz jsou v~kapitole \ref{ch:moduly} vytvoøeny návrhy ro¾¹iøujících modulù {\it
Wrathionu}. 
\chapter{Metody pro ¹ifrování a~he¹ování}
\label{ch:sifrovani}
Chceme--li se bavit o~¹ifrování a~he¹ování musíme si nejprve definovat pojem \uv{kryptografie}.
\begin{defn}
    \uv{Kryptografie je studie matematických technik spojených s~aspekty bezpeènosti informací jako
    napøíklad dùvìrnost, integrita dat, ovìøování entit a~ovìøování pùvodu dat.}~\cite{AC:1996} 
\end{defn}
Pojmy \uv{¹ifrování} a~\uv{he¹ování} vyjadøují dva rùzné pøístupy k~zabezpeèení informací. Oba pojmy
vyjadøují pou¾ití algoritmù nebo funkcí navrhnutých na základì kryptografických pravidel. 

\section{©ifrování}
Pokud potøebujeme zabezpeèit data tak, aby bìhem pøenosu nebyla ètena neoprávnìnou osobou, která by
mohla data jakkoliv získat, bavíme se o~¹ifrování. Pro ¹ifrování potøebujeme heslo, které pou¾ijeme
pro zamaskování informací tak, aby pùvodní zpráva nebyla èitelná. V~pøípadì ¹ifrování v¹ak
potøebujeme umìt data znovu odmaskovat a~tím udìlat èitelnými~\cite{AC:1996}. Podle toho rozli¹ujeme metody na dva
typy:
\begin{itemize}
    \item Symetrické ¹ifry -- pro ¹ifrování i~de¹ifrování jsou pou¾ity stejné klíèe (hesla).
        Nejznámìj¹í metodou je DES, která byla vytvoøena v~roce 1975 spoleèností IBM. Posléze na to
        byla standardizována. V~souèastnosti se ji¾ skoro nepou¾ívá, dala ov¹em základ dal¹ím
        pou¾ívaným ¹ifrovacím metodám. Mezi dal¹í známé symetrické ¹ifry patøí napø.: 3DES, AES, RC4
        a~jiné.
    \item Asymetrické ¹ifry -- v~tomto pøípadì je pro ¹ifrování a~de¹ifrování pou¾it jiný klíè.
        Tento mechanismus na¹el své uplatnìní hlavnì v~elektronických podpisech. Ty pou¾ívají tzv.
        veøejný klíè a~klíè soukromý. Pokud chcemezamaskovat informace pou¾ijeme veøejný klíè pro
        ¹ifrování a~soukromý pro de¹ifrování. Druhá kombinace klíèù slou¾í k~ovìøení dat a~k~¹ifrování.
\end{itemize}
\subsection{Triple Data Encryption Algorithm (TDEA, 3DES)}
Jedná se o~roz¹íøenou verzi metody
DES\footnote{Specifikace na \url{http://csrc.nist.gov/publications/fips/fips46-3/fips46-3.pdf}}.
K~vytvoøení této metody do¹lo na základì nedostateèné bezpeènosti metody DES proti útokùm hrubou
silou. Jedním z~po¾adavkù na novou metodu byla zpìtná kompatibilita s~metodou DES tak, aby
spoleènosti nemusely pøedìlávat své systémy.

TDEA je symetrická bloková ¹ifra vyu¾ívající kryptografické jádro DES k~¹ifrování 64-bitového bloku
dat. Metoda pracuje s~64-bitovým klíèem, ov¹em pro ¹ifrování je pou¾ito pouze 56 bitù, zbylé bity
slou¾í k~detekci chyb. 

Metoda pou¾ívá tøi 56-bitové klíèe pro své operace. Jednotlivé klíèe jsou pou¾ity v~rùzných krocích
zpracování vstupních dat. Provádìné kroky jsou:
\begin{enumerate}
    \item ¹ifrování dat pomocí klíèe K1,
    \item de¹ifrování dat pomocí klíèe K2,
    \item ¹ifrování dat pomocí klíèe K3.
\end{enumerate}
Metoda mù¾e být pou¾ita v~re¾imech:
\begin{itemize}
    \item Klíèe jsou reprezentovány na 168 bitech a~jsou definovány jako K1 $\neq$ K2, K2 $\neq$ K3
        a~K1 $\neq$ K3. Ka¾dý klíè je tedy unikátní.
    \item Klíèe jsou reprezentovány na 112 bitech. Zde jsou definovány jako K1 = K3 a~K1 $\neq$ K2.
    \item Posledním re¾imem je pou¾ití jednoho 56-bitového klíèe, tedy K1 = K2 = K3.
\end{itemize}
První a~druhý re¾im jsou jedinými mo¾nostmi schválenými standardem jako dostateèné. Tøetí re¾im
je pou¾it pouze pro kompatibilitu s~DES. Pokud se toti¾ podíváme na provádìné kroky tak zjistíme,
¾e pokud jsou v¹echny klíèe identické je výstup TDEA identický s~výstupem DES pøi pou¾ití stejného
klíèe~\cite{NIST:2012}.

\subsection{Advanced Encryption Standard (AES)}
Tento standard byl vytvoøen kvùli nedostatkùm ¹ifrovací metody Triple DES v~síle ¹ifrování a
v~rychlosti ¹iforvání dat. Pùvodní název této ¹ifrovací metody je Rijndael. Metoda Rijndael byla
vybrána institutem National Institute of Standards and Technology jako nejlépe vyhovující metoda ze
v¹ech pøihlá¹ených. Standard byl publikován v~roce 2001~\cite{NIST:2001}.

Jedná se o~symetrickou blokovou ¹ifru pou¾ívající 128-bitový datový blok s~promìnnou délkou
¹ifrovacího hesla. Délka hesla mù¾e být 128, 192 nebo 256 bitù. To je reflektováno v~názvu metody
(AES-128, AES-192, AES-256). Metoda pracuje s~daty po bajtech, které pøípadnì organizuje do polí
nebo dvoudimenzionálních polí bajtù. V~metodì AES je pou¾ito dvoudimenzionální pole skládající se
ze ètyø øádkù obsahujících ètyøi bajty. Toto dvou dimenzionální pole je nazýváno {\it State}.

Na zaèátku ¹ifrování se nakopírují data ze vstupu do pole {\it State} a~nastaví se
zaokrouhlovací klíèe ({\it Round Keys}). Poté je, na základì pou¾ité délky ¹ifrovacího klíèe, x--krát
pou¾ita zaokrouhlovací funkce. Poèet opakování funkce je 10-krát pro 128b klíè, 12-krát pro 192b
klíè a~14-krát pro 256b klíè. Funkce se skládá ze ètyø bajtovì-orientovaných transformací:
\begin{enumerate}
    \item nahrazení bajtù pomocí nahrazovací tabulky -- nelineární nahrazení bajtù, které funguje
        nezávisle pro ka¾dý byte pole {\it State},
    \item posun øádkù pole {\it State} o~rùznou hodnotu (offset) -- je pou¾it cyklický posun
        (rotace) vlevo, kde velikost posunu je rovna indexu øádku pole, tedy 0 a¾ 3,
    \item smíchání dat v~rámci ka¾dého sloupce pole {\it State} -- ka¾dý sloupec je pova¾ován za
        samostatný polynom ètvrté úrovnì, nad kterým jsou provádìny operace,
    \item pøidání zaokrouhlovacího klíèe ({\it Round Key}) k~poli {\it State} -- zaokrouhlovací
        klíèe jsou pøidávány pomocí bitové operace XOR provedené nad sloupci pole.
\end{enumerate}
Pro de¹ifrování je pou¾ita inverzní funkce, a~proto¾e se jedná symetrickou ¹ifru, je pro de¹ifrování
pou¾ito stejné heslo jako pro ¹ifrování.

\section{He¹ování}
He¹ování se pou¾ívá k~jednosmìrnému zabezpeèení dat. V~tomto pøípadì se nepou¾ívají hesla pro
zabezpeèení dat. Jde o~kombinaci logických funkcí, bitových rotací, posunù a~zámìny posloupnosti
bitù. Úkolem tìchto metod je na vstupu pøijmout zprávu o~jakékoliv veliskosti a~na výstup produkovat
zprávu o~pevné délce. 

 V~pøípadì optimální he¹ovací funkce nelze pro dvì rùzné vstupní zprávy obrd¾et identické zprávy
výstupní. Toho lze vyu¾ít pro bezpeèné ulo¾ení informací, které není nutné nìkdy v~budoucnosti
pøevést do pùvodního stavu. Tìchto vlastností se vyu¾ívá napøíklad pøi ukládání hesel nebo
ovìøování, zda nedo¹lo pøi pøenosu k~modifikaci dat. Do této skupiny patøí funkce: MD4, MD5, SHA-1,
SHA-2 a~jiné~\cite{AC:1996}.

\subsection{SHA-1}
Slou¾í pro he¹ování zpráv s~maximální délkou $2^{64}-1$ bitù. Jako výstup produkuje 160 bitovou
hodnotu tzv. he¹ (hash). Ten je vìt¹inou uveden v~hexa-decimální formì pro sní¾ení nárokù na ulo¾ení
a vizuálního zkrácení výstupu~\cite{NIST:2015}. 

Existují dvì mo¾nosti, jak vytvoøit výstupní hodnotu. Jedna vy¾aduje více zdrojù, ale ve vìt¹inì
pøípadù potøebuje krat¹í výpoèetní èas. Druhá se spí¹e hodí
pro systémy s~omezenými zdroji, které nevy¾adují co nejrychlej¹í zpracování.


\subsection{SHA-256}
Nástupce SHA-1, mající stejná omezení pro vstupní zprávu jako jeho pøedchùdce, se v¹ak li¹í v~délce
výstupní hodnoty, která má v~tomto pøípadì velikost 256-bitù. To poskytuje podstatnì víc mo¾ných
vypoètených hodnot a~sní¾í se tedy procentuální pravdìpodobnost, ¾e dojde ke kolizi vypoètených
hodnot pro rùzné vstupní zprávy, co¾ se pou¾ívá jako jeden z~mo¾ných útokù na he¹ovací
funkce~\cite{NIST:2015}.

Tato he¹ovací funkce má takté¾ vy¹¹í nároky na zdroje pøi výpoètu výsledku. Nemá takové pamì»ové
nároky jako její pøedchùdce. Av¹ak výpoèet je realizován pomocí ¹esti logických funkcí namísto
pùvodních ètyø. Tím se prodlu¾uje èas potøebný k~získání výsledku.

%\begin{algorithm}[ht]
%    \SetStartEndCondition{ (}{)}{)}\SetAlgoBlockMarkers{}{}%
%    \SetKwProg{Fn}{}{\string:}{}%
%    \SetKwFor{For}{for}{\string:}{}%
%    \SetKwIF{If}{ElseIf}{Else}{if}{}{else if}{else}{}%
%    \SetKwFor{While}{while}{}{}%
%    \SetKwRepeat{Repeat}{repeat}{until}%
%    \SetKwInOut{Input}{vstup}\SetKwInOut{Output}{výstup}
%    \AlgoDisplayBlockMarkers\SetAlgoNoLine%
%    \DontPrintSemicolon
%    \Input{Zpráva $M$ o~délce $l$, kde $0 < l \leq  2^{64}$ bitù}
%    \Output{He¹ o~délce 160--bitù}
%    \Fn{SHA-1 ($M$)}{
%        Zarovnej zprávu, aby výsledek byl násobkem $512$\;
%        Rozdìl novì vytvoøenou zprávu na $N$ blokù po $512$ bitech ($16 * 32$ bitù blok)\;
%        Nastavení výchozích hodnot he¹ù $H^{(0)}_i$, kde $i = \{0,4\}$\;
%        \For{$i = 1;\,i < N;\,i = i~+ 1$}{
%            $W = f_{rozsir}(B)$ \tcc*[r]{z $ 16 * 32$-bit hodnoty na $80 * 32$-bit hodnotu}
%            \tcp*[l]{Inicializuj registry konstantami}
%            $a = H_0,\,b = H_1,\,c = H_2,\,d = H_3,\,e = H_4$\;
%            \For{$t = 0;\, t < 80;\, t = t + 1$}{
%                $s = t \wedge MASK$\;
%                \If{$ t \geq 16$}{
%                    $W_s = ROTL^1(W_{(s+13)\wedge MASK} \oplus W_{(s+8)\wedge MASK} \oplus
%                    W_{(s+2)\wedge MASK} \oplus W_s$\;
%                }
%                \If{$ 0 \leq i~\leq 19$}{
%                    $T = ROTL^5(a) + (x \wedge y) \oplus (\neg x \wedge z) + e + K_t + W_s$\;
%                }
%                \ElseIf{$20 \leq i~\leq 39$ or $60 \leq i~\leq 79$}{
%                    $T = ROTL^5(a) + (x \oplus y \oplus z) + e + K_t + W_s$\;
%                }
%                \ElseIf{$40 \leq i~\leq 59$}{
%                    $T = ROTL^5(a) + (x \wedge y) \oplus (x \wedge z) \oplus (y \wedge z) 
%                        + e + K_t + W_s$\;
%                }
%                $e = d, d = c$\;
%                $c = ROTL^{30}(b)$\;
%                $b = a, a~= T$\;
%            }
%            $H^{(i)}_0 = a~+ H^{(i-1)}_0$\;
%            $H^{(i)}_1 = b + H^{(i-1)}_1$\;
%            $H^{(i)}_2 = c + H^{(i-1)}_2$\;
%            $H^{(i)}_3 = d + H^{(i-1)}_3$\;
%            $H^{(i)}_4 = e + H^{(i-1)}_4$\;
%        }
%        \Return{$concat(H^{(N)}_0, H^{(N)}_1, H^{(N)}_2, H^{(N)}_3, H^{(N)}_4)$}
%    }
%
%    \caption{Princip funkce SHA1} \label{alg:SHA}
%\end{algorithm}

\chapter{Paralelní výpoèty na GPU pomocí OpenCL}
\label{ch:opencl}
Dne¹ním trendem ve vývoji architektur pro výpoèetní zaøízení je umo¾nìní paralelního provádìní
úloh. Jedná se o~architektury otevírající dveøe k~znatelnému zvý¹ení výkonu u~zaøízení na nich
postavených. Dnes ji¾ pova¾ujeme za normální, ¾e máme více jádrové procesory (CPU), které
podporují paralelní zpracování. Ov¹em jedním z~hlavních pøedstavitelù toho trendu jsou grafické 
výpoèetní jednotky (GPU). Existence tìchto typù zaøízení ústí v~potøebu mít prostøedkya, jak s~tìmito
zaøízeními komunikovat a~programovat je.

 U~paralelních aplikací je na¹í nejvìt¹í prioritou efektivnost vyu¾ití zdrojù. Dùvodem je
vysoká poøizovací cena a~èasto i~vysoké provozní náklady. Dal¹ím dùvodem je také nároènost aplikací
na nich bì¾ících. Ty jsou ve vìt¹inì pøípadù èasovì velmi nároèné. Návrh i~programování aplikace
vyu¾ívající paralelismù mù¾e být znaènì nároèné. Je zde velký rozdíl v~programovacích technikách.
Programování paralelních aplikací pro CPU vychází ze za¾itých standardù pro práci s~pamìtí,
procesy nebo pro øízení bìhu aplikace, pou¾ívaných pro vývoj klasických aplikací. Oproti tomu
programování GPU a~jiných specializovanìj¹ích zaøízení se od tìchto standardù velmi li¹í.
Napøíklad vytváøení obecnì pou¾itelné aplikace urèené pro bìh na GPU je nároèné hlavnì z~hlediska
odli¹ného pamì»ovému modelu a~jiné ¹kály funkcí pro práci s~ní. GPU ve znaèné míøe vyu¾ívá
operace pro práci s~vektory. Nejvìt¹ím problémem spojeným s~programováním tìchto zaøízení je ¹kála
rùzných pou¾ívaných architektur. Faktem je, ¾e v¹echny modely pro práci se zaøízeními (pamì»ový
model, model provádìní atd.) se mohou mìnit v~závislosti na platformì, výrobci èi pou¾itím
hardwaru.

 Takovýto vývoj obecnì pou¾itelných aplikací by byl nereálný, proto¾e bychom museli
aplikaci vyvinout v~desítkách ne--li stovkách verzí pro jednotlivá konkrétní zaøízení, na kterých
bychom chtìli aplikaci provozovat. Proto se vyskytla potøeba vytvoøit univerzální rozhraní, je¾ by
nad specifickými pøístupy k~programování jednotlivých zaøízení vytvoøilo univerzální programovací
vrstvu, její¾ instrukce by následnì byly interpretovány do instrukèní sady specifického zaøízení.
Takovýmto rozhraním je napø.: CUDA\footnote{Platforma vyvinutá spoleèností NVIDIA urèená pro
umo¾nìní práce s~GPU této spoleènosti~\cite{NVIDIA}.} nebo OpenCL~\cite{AMD:2011}.

\section{OpenCL}
Jedná se o~otevøený nezpoplatnìný standard slou¾ící k~zjednodu¹ení a~zefektivnìní programování
paralelních aplikací. OpenCL vyu¾ívá rozhraní, které pracuje na velmi nízké úrovni, tedy skoro na
úrovni samotných fyzických souèástek, èím¾ dosahuje vysoké efektivity. Nad tímto rozhraním následnì
vytváøí vrstvu pro výpoèty, jen¾ obsahuje pracovní prostøedky nezávislé na platformì. Hlavní síla
OpenCL je zkombinování paralelních výpoètù aplikace na GPU se zøetìzeným rendrováním grafických
prvkù~\cite{Khronos:2015}.
Standard:
\begin{itemize}
    \item Podporuje datovì i~úlohovì zalo¾ené paralelní programovací modely.
    \item Definuje konzistentní numerické po¾adavky vycházející z~IEEE 754.
    \item Definuje konfiguraèní profil pro pøenosná zaøízení a~vestavìné systémy.
    \item Zaji¹»uje efektivní souèinnost s~OpenGL, OpenGL SE a~dal¹ími grafickými
        rozhraními.
\end{itemize}
Nejedná se pouze o~standard pro psaní paralelních aplikací, ale i~o~stejnojmenný framework, který
je na tomto standardu postaven. Framework OpenCL zahrnuje programovací jazyky, rozhraní pro
programování aplikací (API), knihovny a~systém pro bìh programu ({\it runtime} systém).
\subsection{Architektura OpenCL}
Struktura OpenCL architektury lze popsat hierarchickým modelem následovnì:
\begin{itemize}
    \item model platformy,
    \item model provedení,
    \item model pamìti,
    \item programovací model.
\end{itemize}

\subsubsection{Model platformy}
Tento model se skládá z~hostitele a~jednoho nebo více OpenCL zaøízení, která jsou rozdìlena na
jedno nebo více výpoèetních jednotek. Ty jsou dále dìleny na jeden nebo více výpoèetních prvkù.
Na jednotlivých prvcích se pak provádí výpoèetní operace.

 Rozdìlení na hostitele a~zaøízení vy¾aduje implementovat aplikaci pro obì èásti. Tedy
vytvoøit kód pro hostitele a~kód pro GPU zaøízení ({\it OpenCL kernel}). Vezmeme--li si jako
pøíklad standardní poèítaè tak hostitel je CPU a~zaøízení je GPU, pøípadnì více GPU.
\begin{figure}[ht]
    \begin{center}
	\scalebox{0.3}{
	    \includegraphics{fig/opencl_platform_model}
	}
    \end{center}
    \caption{Model OpenCL platformy \cite{Khronos:2015}}
    \label{platform}
\end{figure}
\subsubsection{Model provedení}
Jak ji¾ bylo zmínìno aplikace se dìlí na dvì èásti. Zde hovoøíme o~kernelech a~o~hostitelovì
programu, pøièem¾ kernel je ten, kdo provádí výpoèty. Tato \uv{práce} je provádìna pomocí
pracovních polo¾ek ({\it work-item}) jen¾ mù¾eme sdru¾ovat do pracovních skupin ({\it
work-group}).

 Hostitel má za úkol spravovat kontext aplikace a~na jeho základì nastavit prostøedí, ve
kterém bude kernel provádìt operace. V~prostøedí musíme specifikovat a~nastavit tyto polo¾ky:
\begin{itemize}
    \item Zaøízení -- jedno a~více zaøízení ovladatelných platformou OpenCL.
    \item Objekty kernelu -- OpenCL funkce s~pøednastavenými argumenty podle vybraného
        zaøízení.
    \item Objekty programu -- zdrojový kód a~jeho spustitelná verze, které implementují
        kernely.
    \item Objekty pamìti -- promìnné, ke kterým mù¾e pøistupovat hostitel i~OpenCL zaøízení.
	Instance kernelù bìhem svého provádìní operují s~tìmito objekty.
\end{itemize}
Hostitel se zaøízením komunikuje pomocí front pøíkazù, do nich¾ se pøíkazy rozøadí podle
typu operace. Jednotlivé pøíkazy ve frontì se provádí relativnì k~ostatním pøíkazùm. Poøadí
provádìní mù¾e být definováno následujícími modely:
\begin{itemize}
    \item {\it In-order} -- pøíkazy se provádí a~mají efekt tak, jak do fronty pøi¹ly.
    \item {\it Out-of-order} -- poøadí provedení pøíkazù je omezeno pouze explicitnì uvedenými
        synchronizaèními body nebo explicitnì definovanými závislostmi na událostech.
\end{itemize}

\subsubsection{Model pamìti}
Práce s~pamìtí v~OpenCL se znaènì li¹í od klasického pøístupu, který známe ze standardních
aplikací urèených pro bìh pouze na CPU. Pamì»ový model OpenCL popisuje obsah, strukturu a~chování
pamìti pou¾ívané v~platformì vytvoøené tímto frameworkem.

 Pro ka¾dou aplikaci je tøeba pøesnì definovat, jak pøesnì bude její pamì» vypadat.
Model dìlíme na ètyøi èásti:
\begin{itemize}
    \item {\it Oblasti pamìti} -- definuje, se kterými oblastmi pamìti hostitel a~zaøízení ve
	stejném kontextu mohou pracovat.
    \item {\it Objekty pamìti} -- jsou definované v~OpenCL API, o~správu se stará hostitel i
	zaøízení.
    \item {\it Sdílenou virtuální pamì»} -- jedná se o~virtuální adresový prostor pøístupný obìma
	èástem aplikace.
    \item {\it Model konzistence} -- definuje pravidla pro oblasti pamìti, které jsou pou¾ívané
	více jednotkami naráz a~zaruèuje, ¾e je dodr¾eno poøadí operací s~pamìtí a~¾e jsou data po
	celou dobu validní. Takté¾ definuje synchronizaci nad tìmito oblastmi.
\end{itemize}
Pro nás je nejdùle¾itìj¹í pochopit, jak je pamì» strukturována a~jak na sebe navazují
jednotlivé oblasti. To je nejlépe patrné z~obrázku \ref{memory}. Popis struktury:
\begin{itemize}
    \item pamì» hostitele (RAM apod.),
    \item pamì» zaøízení,
    \begin{itemize}
	\item {\it globální pamì»} -- oblast je pøístupná pro ètení i~zápis v¹em jednotkám
v~kontextu nezávisle na zaøízení,
	\item {\it pamì» konstant} -- pøed zahájením výpoètu je alokovaná a~inicializována
	    hostitelem a~v~prùbìhu výpoètu se tato oblast nemìní výpoètu,
	\item {\it lokální pamì»} -- oblast je pøístupná v¹em pracovním polo¾kám ve
	    stejné pracovní skupinì,
	\item {\it soukromá pamì»} -- oblast je pøístupná pouze jedné pracovní polo¾ce.
    \end{itemize}
\end{itemize}
\begin{figure}[ht]
    \begin{center}
	\scalebox{0.3}{
	    \includegraphics{fig/opencl_memory_structure}
	}
    \end{center}
    \caption{Struktura pamìti OpenCL \cite{Khronos:2015}}
    \label{memory}
\end{figure}
\subsubsection{Programovací model}
Tento model lze také nazvat jako OpenCL framework. Framework se skládá ze tøech komponentù. Zde za
zmínku stojí OpenCL kompilátor. Ten podporuje pokroèilý jazyk SPIR-V a~jazyk OpenCL C. Dal¹í
jazyky mohou být podporovány nìkterými implementacemi kompilátoru.


\chapter{Nástroj Wrathion}
\label{ch:wrathion}
Jedná se o~nástroj vytvoøený Janem Shmiedem v~roce 2014 v~rámci jeho diplomové
práce~\cite{Schmied}. Nástroj byl vytvoøen pro pou¾ití v~projektu {\it Moderní prostøedky pro 
boj s~kybernetickou kriminalitou na Internetu nové generace, MV, VG20102015022}.
\section{Hlavní èásti Wrathionu}
Nástroj slou¾í ke obnovování hesel pomocí brute-force útokù na tato hesla. Skládá se ze tøí
èástí:
\begin{itemize}
	\item jádra -- zprostøedkovávajícího funkcionalitu potøebnou pro crackování,
	\item modulù -- skrze které je zaji¹tìna podpora crackování rùzných formátù,
	\item aplikace -- umo¾òující pracovat s~frameworkem a~moduly pomocí CLI rozhraní.
\end{itemize}
\begin{figure}[ht]
    \begin{center}
	\scalebox{0.34}{
	    \includegraphics{fig/wrathion_structure}
	}
    \end{center}
    \caption{Schéma struktury nástroje Wrathion \cite{Hranicky}}
    \label{memory}
\end{figure}
\subsection{Generátory hesel}
První èástí Wrathionu, kterou si rozebereme jsou generátory hesel pro útoky. Jedná se o~esenciální
funkcionalitu. Bez vygenerovaných hesel nemù¾eme na útoky vùbec myslet. V~nástroji jsou momentálnì
implementovány tøi typy generátorù:
\begin{itemize}
    \item {\it Brute-force} -- postupnì generuje v¹echny mo¾né permutace ze zadaných znakù.
    \item {\it Unicode} -- jedná se o~upravený brute-force generátor. V~tomto pøípadì je nastavena
	vstupní abeceda na v¹echny Unicode znaky a~z~nich jsou generovány mo¾né permutace hesel.
    \item {\it Rule-based} -- velmi podobný pøedchozím variantám ov¹em umo¾òuje specifikovat rùzná
	podpùrná pravidla pro generování hesel. Napøíklad, ¾e má být první písmeno velké, druhé má
	být 'a' a~¾e poslední 2 znaky jsou èíslice. Toto umo¾òuje zú¾ení poètu permutací a~tedy
	sni¾uje èas potøebný k~vygenerování v¹ech jejich variant (tento typ generátoru je teprve
	ve vývoji).
    \item {\it Dictionary} -- slovníkový generátor, který vyu¾ívá externí soubory s~èasto
	pou¾ívanými hesly.
\end{itemize}
Nejèastìji pou¾ívaným generátorem je brute-force, který je ov¹em výpoèetnì nároèný. Jedná se
v¹ak o~snadno paralelizovatelný generátor, proto je pøíhodnì implementován i~jako kernel bì¾ící na
GPU.
\subsection{Crackery}
Druhou èástí jsou samotné crackery, které dìlíme podle toho, kdo provádí generování hesel a
kdo provádí porovnávání hesel:
\subsubsection{CPU cracker}
Zde se standardnì spustí ji¾ pøedkompilovaný cracker napsaný v~C++ (viz. Obrázek \ref{CPU}). Není
zde ¾ádný vìt¹í problém s~generováním ani následným ovìøováním hesel, ov¹em výpoèetní síla
u~paralelizovatelných algoritmù není CPU ani zdaleka tak vysoká jako na GPU. Proto, pokud je to
mo¾né, volíme druhou variantu crackeru.
\begin{figure}[ht]
    \begin{center}
	\scalebox{0.3}{
	    \includegraphics{fig/proces}
	}
    \end{center}
    \caption{Proces generování a~ovìøování hesel na CPU \cite{Schmied}}
    \label{CPU}
\end{figure}

\subsubsection{GPU cracker}
Cracker mù¾e pracovat ve dvou re¾imech (viz. Obrázek \ref{CPUGPU}). V~prvním hesla generujeme na
CPU a~pak je posíláme do pamìti GPU, kde jsou crackerem zpracována. To má ov¹em velkou nevýhodu
v~tom, ¾e musíme poøád posílat data z~pamìti hostitele (CPU) do privátní pamìti výpoèetního prvku
(výpoèetní jednotka na GPU).
\begin{figure}[ht]
    \begin{center}
	\scalebox{0.32}{
	    \includegraphics{fig/generators}
	}
    \end{center}
    \caption{Proces generování hesel na CPU a~ovìøování na GPU \cite{Schmied}}
    \label{CPUGPU}
\end{figure}

 Druhou a~efektivnìj¹í mo¾ností je generovat hesla pøímo na GPU do privátních pamìtí èím
minimalizujeme mno¾ství dat, které musí putovat od hostitele k~zaøízení. Tímto sní¾íme výslednou
prodlevu výpoètù.

 V~obou pøípadech je nutné pøed zahájením jakýchkoliv operací GPU
 inicializovat\linebreak OpenCL systém. Tedy vytvoøit kontext, fronty pøíkazù, zajistit naètení a
 pøelo¾ení po¾adovaného kernelu a~a¾ poté nahrát nebo vygenerovat data do/na GPU.

\subsection{Moduly}
Nástroj je navr¾en s~velkým dùrazem na modularitu. V~souèasné dobì obsahuje pouze tøi moduly.
Dal¹í moduly pro Wrathion jsou ve fázi vývoje.

\subsubsection{Modul ZIP}
V~této práci nás nejvíce zajímá modul ZIP. Ten v~pùvodním návrhu obsahuje pouze ¹ifrování
obnovování hesel z~archivù ¹ifrovaných algoritmy PKZIP, AES-128, AES-192, AES-256, co¾ zanechává
prostor pro implementaci dal¹ích, formátem {\it .ZIP}, podporovaných metod. Zajímavostí je, ¾e
tento modul byl schopný v~dobì svého vzniku obnovit heslo ¹ifrovaných {\it .DOCX} souborù, av¹ak
tento nedostatek u~zabezpeèení formátu {\it .DOCX} byl pozdìji odstranìn a~tento modul ji¾ tedy
není schopen obnovit heslo u~souborù vytvoøených po zmínìné aktualizaci.

\subsubsection{Modul DOC}
Dal¹í modul pracuje s~formátem {\it .DOC}, který byl pokládán za základní formát aplikace MS Word
z~balíku MS Office. Tento formát byl s~pøíchodem MS Office 2007 nahrazen formátem {\it .DOCX}.
Nástroj ve své pùvodní podobì obsahuje pouze podporu pro {\it .DOC} formát. Tvorba modulù pro
novìj¹í formát {\it .DOCX} spolu s~formáty pou¾ívanými v~jiných aplikacích balíku MS Office je ve
fázi vývoje.

\subsubsection{Modul PDF}
Prozatím poslední vytvoøený modul pracuje s~formátem {\it .PDF}. Zde jsou ji¾ implementovány
bezpeènostní revize 1-5. Nástroj poèítá i~s~implementací revize 6. Vývoj této funkcionality mù¾e
být zapoèat a¾ po zveøejnìní specifikace této revize.

\chapter{Analýza formátù .ZIP a~.7z}
\label{ch:formaty}
\section{Formát .ZIP}
Jedná se o~jeden z~prvních formátù souborových archivù, který podporoval kompresi dat. V~roce 1989
vytvoøil Phil Katz program PKZIP v~rámci nìho¾ byl pøedstaven nový formát .ZIP. Specifikace
formátu .ZIP byla publikována pod veøejnou doménou. Tímto krokem pomohl formátu se stát
celosvìtovým otevøeným standardem~\cite{PKWARE:2015}. V~roce 2015 byl formát, ve své specifikaci
6.3.3 z~roku 2012, pøijat Mezinárodní organizací pro normalizaci (ISO) a~Mezinárodní
elektrotechnickou komisí (IEC) jako¾to standard definovaný dokumentem ISO/IEC
21320-1:2015~\cite{ISOIEC:2015}.

 Formát podporuje velké mno¾ství rùzných komprimaèních algoritmù: Store(bez komprese),
UnShrinking, Expanding, Imploding, Tokenizing, Deflating, Enhanced Deflating, BZIP2, LZMA, WavPack
a PPMd~\cite{PKWARE:2014}. 

 Obdobnì je to i~s~podporou rùzných ¹ifrovacích algoritmù:
\begin{itemize}
    \item {\it PKWARE ¹ifrování} -- prvotní ¹ifrování,
    \item {\it DES, 3DES(112-bit a~168-bit)} -- podporováno od verze 5.0 z~roku 2002,
    \item {\it RC2 (40-bit, 64-bit a~168-bit)} -- podporováno od verze 5.0 z~roku 2002,
    \item {\it RC4 (40-bit, 64-bit a~168-bit)} -- podporováno od verze 5.0 z~roku 2002,
    \item {\it AES (128-bit, 192-bit a~256-bit)} -- podporováno od verze 5.2 z~roku 2003.
\end{itemize}
Nastává zde ale problém, ¾e ¾ádný z~a» u¾ volnì dostupných nebo komerèních nástrojù
neumo¾òuje vytvoøení archivù se ¹ifrováním DES, RC2 a~RC4. Z~toho tedy plyne, ¾e pravdìpodobnost
výskytu archivù ¹ifrovaných tìmito metodami je minimální respektive témìø nulová.

\subsection{Struktura souboru}
\label{ssec:zip_struct}
Archivy jsou soubory obsahující dal¹í soubory. Dá se tedy øíct, ¾e se jedná
o~jakési\linebreak\uv{schránky}, do nich¾ lze vkládat, ale i~vybírat, urèité soubory rùzných typù.
U~formátu .ZIP lze do archivù navíc ukládat i~adresáøe a~tak ukládat
celé struktury tvoøené z~adresáøù a~souborù \ref{zipstruct}.
\begin{figure}[ht]
    \begin{center}
	\scalebox{0.225}{
	    \includegraphics{fig/zip_structure}
	}
    \end{center}
    \caption{Struktura .ZIP souboru \cite{PKWARE:2014}}
    \label{zipstruct}
\end{figure}

 Obsah souboru archivu lze pro lep¹í orientaci rozdìlit na èást obsahující definice a~data
ulo¾ených souborù a~na èást reprezentující organizaci adresáøù a~souborù.
\begin{itemize}
    \item První èást obsahuje záznamy, jen¾ se opakují pro ka¾dý ulo¾ený soubor. Jeden takovýto
záznam musí obsahovat alespoò lokální hlavièku souboru a~data souboru. Pokud je nastaven
3. bit polo¾ky {\it General purpose bit flag} v~lokální hlavièce souboru tak musíme je¹tì poèítat
s~tím, ¾e za data byla pøidána sekce {\it Data description} o~velikosti 12 bajtù.
    \item Druhá èást se skládá ze struktury hlavièek centrálního adresáøe (Central Directory
Header). Poèet tìchto hlavièek odpovídá poètu adresáøù a~souborù obsa¾ených v~tomto
archivu. Hlavièka centrálního adresáøe zaèíná signaturou [0x50, 0x4b, 0x01, 0x02], podle které je
v~souboru identifikovatelný zaèátek hlavièky. Za ní následují metadata souboru. Napø.: datum a~èas
poslední úpravy obsa¾eného souboru, velikost pøed a~po kompresi atd. Tato struktura hlavièek je
ukonèena záznamem konec centrálního adresáøe. Ten zaèíná signaturou [0x50, 0x4b, 0x05, 0x06]
a~obsahuje informace o~tom na kterém disku je soubor ulo¾en, na kterém disku zaèíná struktura
centrálního adresáøe a~dal¹í.
\end{itemize}
Od verze formátu 6.2 jsou pøed hlavièkou centrálního adresáøe dal¹í polo¾ky a~to hlavièka
pro de¹ifrování archivu a~záznam o~extra datech archivu. Tyto polo¾ky byly pøidány
v~závislosti na pøidání nové funkce pro ¹ifrování obsahu hlavièek centrálního adresáøe.

\subsubsection{Øídící struktury definující ¹ifrování}
 Zatím jsme se bavili pouze o~základní struktuøe archivu. Nás ale spí¹e zajímají struktury
archivù, jen¾ obsahují soubory v~za¹ifrované podobì. Zda je soubor ¹ifrován lze zjistit z~jeho
lokální hlavièky nebo z~jeho hlavièky centrálního adresáøe a~konkrétnì z~prvního a~sedmého bitu
polo¾ky {\it General Purpose Bit Flag}. Nastavení prvního bitu indikuje, ¾e je soubor ¹ifrován.
\begin{itemize}
    \item Pokud platí, ¾e není zároveò nastaven i~sedmý bit, je za lokální hlavièku souboru
        pøidána hlavièka ¹ifrování. Hlavièka ¹ifrování se vá¾e pouze k~¹ifrování pomocí tradièní
        metody od spoleènosti PKWARE.
    \item Pokud je nastaven i~sedmý bit indikující pou¾ití takzvaného \uv{silného
	¹ifrování}, hlavièka ¹ifrování se negeneruje, ale pøidávají se informace o~¹ifrování do
        hlavièky centrálního adresáøe a~generuje se záznam s~hlavièkou pro de¹ifrování, jeho¾
	èást se tváøí jako souèást dat souboru a~nachází se na samém poèátku ¹ifrovaných dat
	souboru.
\end{itemize}
Informace o~metodì ¹ifrování, délce klíèe atd., jsou uvedeny v~druhé èásti souboru
z~dùvodù vy¹¹í bezpeènosti. Pøesnìji v~polo¾ce {\it Extra Fields} v~hlavièce centrálního adresáøe
pøíslu¹ící souboru. Polo¾ku {\it Extra Fields}, poznáme podle její signatury, kterou zaèíná a~má
hodnotu [0x00, 0x17]. Dal¹í polo¾ky obsahují informace o~pou¾itém ¹ifrovacím algoritmu, délce
klíèe pro ¹ifrování a~pole pøíznakù {\it Flags} definující, zda je archiv ¹ifrovaný, jaká je
pou¾ita kompresní metoda, co je vy¾adováno pro de¹ifrování, zda je vy¾adováno pouze heslo nebo
pouze certifikát nebo je mo¾né pou¾ít buï heslo, nebo certifikát. Dal¹í mo¾nosti závisí na pou¾itém
certifikátu.

 Záznam pro de¹ifrování obsahuje o~inicializaèní vektor (IV, sùl), identifikátor algoritmu pro
de¹ifrování, bitovou délku ¹ifrovacího klíèe, za¹ifrovaný vzorek náhodných dat (Erddata) a~hlavnì
o~informace pro validaci hesla (VData) a~CRC-32 (VCRC32)\footnote{{\it Cyclic Redundancy Code} -
speciální he¹ovací funkce slou¾ící pro detekci chyb / zmìn dat oproti pùvodní hodnotì} tìchto
validaèních dat. 



\section{Formát .7z}
\label{sec:7z}
Vznik tohoto formátu se datuje do roku 1999 a~jeho autorem je Igor Pavlov. Stejnì jako aplikace
7-Zip a~nástrojù spojených s~tímto formátem (7-Max, 7-Benchamark). Formát takté¾ slou¾í
k~vytvoøení souborových archivù podobnì jako .ZIP. Formát se proslavil hlavnì svojí otevøeností a
modulární strukturou. Ta umo¾òuje skládání libovolných kompresních, konverzních a~¹ifrovacích
metod.

 Mezi podporované kompresní metody se øadí LZMA, LZMA2, PPMD, BCJ, BCJ2, BZip2 a
Deflate. Jako výchozí metoda je brána LZMA. Hlavní výhody této metody jsou~\cite{7z:2015}:
\begin{itemize}
    \item vysoký kompresní koeficient,
    \item promìnná velikost slovníku,
    \item malé nároky na pamì» pøi dekompresi,
    \item podpora zpracování pomocí multi-threading a~hyper-threading.
\end{itemize}
Dal¹í výhodou formátu je podpora komprese velkých souborù, názvy souborù v~Unicode
kódování, mo¾nost spojení více souborù do jednoho toku, který je pak teprve komprimován, komprese
a ¹ifrování hlavièek archivù a~dal¹í.

 Standardnì pou¾itou ¹ifrovací metodou je AES-256 vy¾adující 256-bitové ¹ifrovací heslo.
Takovéto heslo se vytváøí pomocí he¹ovací funkce SHA-256 z~u¾ivatelem zadaného hesla. Pro je¹tì
vy¹¹í zabezpeèení je provedeno \(2^{19}\) iterací pøi ka¾dém vytváøení hesla. To mù¾e mít na
slab¹ích zaøízeních za následek znatelnou prodlevu, ne¾ zaène komprese souborù a~¹ifrování.

\subsection{Struktura souboru}
\label{ssec:7z_struct}
Neprázdný soubor tohoto formátu má ètyøi èásti, které v~nìm musí být obsa¾eny viz.
\ref{7zstruct}. Jedná se o~polo¾ky: 
\begin{itemize}
    \item První èást se nachází hned zaèátku souboru a~jedná se o~hlavièku se signaturou ({\it
	7zSignature}) ['7', 'z', 0xBC, 0xAF, 0x27, 0x1C] definující zaèátek souboru daného typu.
	Za ní v~rámci stejné hlavièky jsou informace o~verzi archivu, CRC hlavièky a~jako poslední
	jsou polo¾ky týkající se pozice následující hlavièky. Najdeme zde relativní adresu
	(uvedena jako vzdálenost od konce úvodní hlavièky), následuje pak délka dal¹í hlavièky a~CRC pro tyto dvì polo¾ky.
    \item Druhá èást obsahuje zpracovaná data vytvoøených proudù, tedy data samostatných nebo
	pøípadnì i~spojených souborù po kompresi, ¹ifrování apod.
    \item Tøetí èást obsahuje zpracované informace slou¾ící jako podpùrná data pro hlavièku a~její
	polo¾ky.
    \item Poslední ètvrtá èástí je 7z hlavièka ({\it 7zHeader}), její¾ zaèátek je definován
	v~úvodní hlavièce. Tato hlavièka má promìnnou délku a~strukturu. Je ji tedy potøeba
	procházet postupnì a~zji¹»ovat, které polo¾ky jsou pøítomny a~které ne. K~identifikaci
	jednotlivých polo¾ek slou¾í jednobajtový identifikátor zapsaný v~hexadecimální formì.
	Identifikátory zaèínají hodnotou 0x00 a~konèí 0x19. Máme tedy k~dispozici 25 polo¾ek
	s~rùznou velikostí, strukturou a~polo¾kami. Jedinými povinnými údaji v~hlavièce jsou
	polo¾ky znaèící zaèátek hlavièky (0x01) a~konec hlavièky (0x00). V¹echny ostatní polo¾ky
	jsou pøípadnì umístìny mezi nì a~zaèínají pøíslu¹ným identifikátorem~\cite{Pavlov:2010}.  
\end{itemize}
\begin{figure}[ht]
    \begin{center}
	\scalebox{0.35}{
	    \includegraphics{fig/7z_structure}
	}
    \end{center}
    \caption{Struktura .7z souboru \cite{Pavlov:2015}}
    \label{7zstruct}
\end{figure}
Pro úèely této práce nás pøedev¹ím zajímá hlavièka {\it 7zHeader} a~v~ní obsahy polo¾ek nesoucích
informace o~proudech dat (0x03 nebo 0x04). V~nich konkrétnì polo¾ka informace o~kóderech (0x07),
ve které se musíme propracovat k~poli bajtù {\it CodecInfo}. Hodnoty tohoto pole musíme otestovat
a zjistit, zda se shodují s~identifikátorem standardní ¹ifrovací metody AES-256 + SHA-256
[0x06, 0xF1, 0x07, 0x01]~\cite{Pavlov:2015}.

\section{Srovnání}
Pokud budeme srovnávat formáty z~pohledu komprese, zjistíme, ¾e .7z je dle mìøení efektivnìj¹í
ne¾
.ZIP\footnote{\url{http://www.howtogeek.com/200698/benchmarked-whats-the-best-file-compression-format/}}. Ov¹em nás spí¹e zajímá zabezpeèení.

 ©ifrování formátu .ZIP metodou PKZIP nemá smysl ani porovnávat s~ostatními, nebo» se jedná
o~metodu, která ji¾ nedostaèuje dne¹ním bezpeènostním standardùm~\cite{PKWARE:2014}. 

 Pokud se ale podíváme na silnìj¹í metody zabezpeèení, zjistíme, ¾e formáty jsou z~hlediska
bezpeènosti vyrovnané. Oba dva podporují AES-256 s~vyu¾itím nìjaké he¹ovací metody pro zabezpeèení
hesla. Oba formáty také podporují ¹ifrování hlavièek obsahujících informace o~metodách, které jsou
pou¾ívány a~jaké soubory obsahují.

 Formát .ZIP pøekonává .7z mo¾ností pou¾ití elektronických podpisù (certifikát typu X.509v3)
 k~¹ifrování souborù namísto hesel. 7z tuto funkcionalitu vùbec neobshahuje. 


\chapter{Návrh modulù}
\label{ch:moduly}
V~této kapitole se podíváme na to, jak z~vý¹e popsaných algoritmù, technologií a~strukturálních
analýz archivù vytvoøíme roz¹iøující moduly pro nástroj Wrathion. Tato kapitola si klade za cíl
obecnì popsat, jak se budou soubory jednotlivých formátù procházet. Tedy jaká data se z~nich budou
èíst, jaké operace je potøeba provést nad vygenerovanými hesly a~jak se bude provádìt ovìøování
shody hesel.

\section{Modul ZIP}
Jako první si nastíníme modul ZIP. Nemusíme zde øe¹it návrh celého modulu a~v¹ech
mo¾ností pro formát, ale pouze roz¹íøení funkcionality o~zatím nepodporavané metody zabezpeèení.

 Momentální verze ZIP modulu podporuje pouze staré ¹ifrování PKWARE a~¹ifrování AES. Podpora
¹ifrování AES je v¹ak neúplná. Modul momentálnì podporuje pouze speciální verzi AES, je¾ si
vytvoøili vývojáøi nástroje WinZip. Ti si vytvoøili vlastní oøezanou AES hlavièku a~oznaèili
soubor vlastní metodou. Existují ov¹em nástroje jako SecureZIP od firmy PKWARE umo¾òující také
za¹ifrovat obsah archivù pomocí ¹ifrovací metody AES, s~ní¾ si souèasný modul i~pøes podporu
zji¹tìní hesla pro AES neporadí.

 Dal¹í ¹ifrovací metodou, kterou nabízí nástroj SecureZIP je 3DES. S~ním si momentální verze
neporadí vùbec a~je tedy vhodné tuto funkcionalitu doplnit.

\subsubsection{Zji¹tìní informací z~archivu}
Následující text popisuje postup získávání a~zpracování informací nutných pro rozhodnutí, zda se
jedná o~ZIP soubor, zda je soubor ¹ifrován, jakou metodou je ¹ifrován, jaké jsou inicializaèní
hodnoty pou¾ité pøi ¹ifrování apod. To v¹e je potøeba pro roz¹íøení funkcionality modulu. Popis se
primárnì nesoustøedí na získání dat pro ji¾ implementované funkce, ale pouze dat dùle¾itých pro
roz¹íøení funkcionality modulu (detailní popis hlavièek a~hodnot v~nich je v~sekci
\ref{ssec:zip_struct}):
\begin{enumerate}
    \item Zji¹tìní signatury -- podíváme se na první 4 bajty a~porovnáme je se signaturou [0x50,
	0x4B, 0x03, 0x04]. Tím ovìøíme, zda se jedná o~ZIP soubor.
    \item Pøeètení {\it General purpose bit flag} -- hodnotu pøíznakù (flagù) získáme
z~nìkteré z~hlavièek\footnote{Lokální hlavièka souboru nebo hlavièka souboru v~centrálním
	adresáøi. Hlavièka souboru v~centrálním adresáøi obsahuje v¹echny polo¾ky lokální hlavièky
	plus nìjaké navíc.} prvního souboru.
    \item Analýza pøíznakù -- zji¹»ujeme zda jsou nastaveny první a~sedmý bit pøíznakù na hodnotu
	1. Pokud nalezneme ¹ifrování u~jednoho souboru pøedpokládáme, ¾e v¹echny ostatní soubory
	jsou takté¾ ¹ifrované a~¾e byla pou¾ita stejná ¹ifrovací metoda. Pokud je nastaven i~13.
	bit musíme provést ètení de¹ifrovací hlavièky archivu a~pomocí ní de¹ifrovat celou
	strukturu centrálního adresáøe. Postup de¹ifrování je identický s~de¹ifrováním souborù.
    \item Pøeètení {\it Compression method} -- z~nìkteré z~hlavièek %\footnotemark[\value{footnote}] 
	souboru. Tato polo¾ka nás zajímá, pouze pokud byly bity jedna a~sedm pøíznakù nastaveny na
	hodnotu 1. Èíslo uvedené v~této polo¾ce nám dovoluje zjistit, zda byla pou¾ita ¹ifrovací
	metoda WinZip AES (hodnota 99). Pou¾ití jiné hodnoty indikuje pou¾ití nìkteré z~dal¹ích
	¹ifrovacích metod definovaných ve specifikaci formátu .ZIP~\cite{PKWARE:2014}.
    \item Pøeètení {\it Extra fields} -- potøebujeme najít hlavièku s~daty o~¹ifrování, která se
	mù¾e vyskytnout pouze za hlavièkou souboru v~centrálním adresáøi. V~tomto kroku zjistíme
	informace o~pou¾ité ¹ifrovací metodì, délce klíèe atd.
    \item Získání hodnot hlavièky pro de¹ifrování -- nachází se pøed ulo¾enými daty souboru.
	Potøebujeme získat pou¾itá inicializaèní data potøebná pro ¹ifrovací s~de¹ifrovací funkce.
	A~také data pro ovìøení hesla vèetnì jejich kontrolního souètu (CRC32).
\end{enumerate}
Jakmile takto získáme v¹echna potøebná data, pøesuneme se k~hledání pou¾itého hesla. Tento proces
bude mo¾né realizovat za vyu¾ití CPU nebo GPU. Pro obì tato zaøízení je nutné vytvoøit samostatný
kód. Kód pro CPU èistì v~jazyce C++ s~mo¾ností vyu¾ití nìkterých ji¾ implementovaných funkcí a
generátorù obsa¾ených v~nástroji Wrathion. Pro GPU je tøeba vytvoøit kód v~C++, který pobì¾í na
CPU a~bude inicializavat GPU a~rozdìlovat práci pracovním jednotkám na ní umístìných a~poté kernel
v~OpenCL pro implementování kernelu, který pobì¾í na pracovních jednotkách. Av¹ak v~obou
pøípadech pùjde o~toto¾ný Algoritmus \ref{alg:zip_ver}.

\begin{algorithm}[ht]
    \SetStartEndCondition{ (}{)}{)}\SetAlgoBlockMarkers{}{}%
    \SetKwFor{For}{for}{\string:}{}%
    \SetKwIF{If}{ElseIf}{Else}{if}{}{else if}{else}{}%
    \SetKwRepeat{Repeat}{repeat}{until}%
    \SetKwInOut{Input}{vstup}\SetKwInOut{Output}{výstup}
    \AlgoDisplayBlockMarkers\SetAlgoNoLine%
    \DontPrintSemicolon
    \Input{Data získaná z~hlavièky pro de¹ifrování (IV, Erd, VDlen, Data)}
    \Output{Poslední vygenerované heslo}
    $shoda = FALSE$\;
    \Repeat{$shoda$}{
	heslo = generujHeslo ()\;
	odvozene\_heslo = odvodHeslo (SHA1(heslo))\;
	rd = desifruj (Erd, odvozene\_heslo, IV)\tcc*{Random hodnotu pro ¹ifrování}
	odvozene\_heslo = odvodHeslo (SHA1(rd + IV))\;
	desifrovana\_data = desifruj (Data, odvozene\_heslo, IV)\;
	presun (Data, VDlen, VData)\tcc*{VDlen bajtù z~Data do VData} 
	VCRC32 = Data\;
	CRC = spocitejCRC32 (VData)\;

	\If{$ CRC ==  VCRC32 $}{
	    $shoda = TRUE$\;
	}
    }
    \caption{Princip ovìøení vygenerovaného hesla pro ZIP archiv}\label{alg:zip_ver}
\end{algorithm}



\section{Modul 7z}
V~tomto pøípadì se jedná o~úplnì nový modul. Bude tedy potøeba nadefinovat v¹echny struktury
potøebné k~provozu modulu v~rámci nástroje Wrathion a~implementovat metody ¹ifrování, he¹ování,
odvozování hesel a~jiné pou¾ívané formátem .7z.

\subsubsection{Zji¹tìní informací z~archivu}
Archiv formátu .7z v~sobì, stejnì tak jako .ZIP archiv, nese informace nutné pro umo¾nìní
de¹ifrování souboru. V~tomto pøípadì je v¹ak o~nìco slo¾itìj¹í je získat. Struktura 7z archivu
je hodnì komplexní a~promìnlivá. Struktura hlavièek do znaèné míry pøipomíná databázi. Pro
detailní porozumìní struktuøe øídících dat formátu je tøeba nahlìdnout do souboru
7zFormat.txt~\cite{Pavlov:2010}. Potøebné informace lze získat následujícím znaènì zjednodu¹eným
teoretickým postupem:
\begin{enumerate}
    \item Ovìøíme signaturu -- jedná se o~prvníich 6 bajtù souboru, které musí odpovídat hodnotì
v~sekci \ref{ssec:7z_struct}. 
    \item Získáme pozici a~velikost dal¹í hlavièky -- pøeskoèíme na pozici 6 bajtù za signaturou
        a~získáme pozici dal¹í hlavièky. Z~následující hodnoty získáme délku následující hlavièky.
    \item Pøejdeme na dal¹í hlavièku -- musíme se podívat na signaturu hlavièky, pokud odpovídá
	hodnotì 0x17 musíme projít její obsah.
    \item Detekce ¹ifrování hlavièky -- v~hlavièce {\it Folders} zaèínající signaturou 0x0B,
	nejprve hledáme hodnotu [0x06, 0xF1, 0x07, 0x01]. Její nález znamená, ¾e data hlavièky jsou
	¹ifrována metodou 7zAES.
    \item Získání dat pro ¹ifrování -- v~pøípadì nálezu èteme data inicializaèního vektoru a~poèet
	iterací pou¾ití he¹ovací funkce pro odvození hesla pro ¹ifrování (defaultnì 19).
    \item De¹ifrování hlavièky -- de¹ifrujeme podle Algoritmu~\ref{alg:7z_desifr}.
    \item Detekce hlavièky pro dekompresi -- hledáme ve stejné sekci jako v~bodì 5. Zde v¹ak
	pátráme po hodnotì [0x03, 0x01, 0x01] znaèící pou¾ití LZMA pro kompresi.
    \item Provedeme dekompresi hlavièky -- pomocí algoritmu LZMA.
    \item Vypoèítáme CRC dat po dekompresi.
    \item Porovnáme vypoètené CRC s~odpovídajícím CRC ulo¾eným v~hlavièce {\it Digest}, pokud
	nesouhlasí, vracíme se na krok 6.
    \item Pro zji¹tìní hesla k~souborùm se podíváme do dekomprimovaných dat a~postupujeme od kroku
	4 obdobným zpùsobem, av¹ak nyní pracujeme s~daty souvisejícími se soubory namísto
        s~hlavièkou.
\end{enumerate}
\begin{algorithm}[H]
    \SetStartEndCondition{ (}{)}{)}\SetAlgoBlockMarkers{}{}%
    \SetKwFor{For}{for}{\string:}{}%
    \SetKwInOut{Input}{vstup}\SetKwInOut{Output}{výstup}
    \AlgoDisplayBlockMarkers\SetAlgoNoLine%
    \DontPrintSemicolon
    \Input{Data získaná z~hlavièky pro de¹ifrování (IV, pocet\_iteraci) a~¹ifrovaná data}
    \Output{De¹ifrovaná data (neovìøená)}
    heslo = generujHeslo ()\;
    retezec = vytvorRetezec(heslo)\tcc{512 * pár (heslo, 64b èíslo <0,512))}
    \For{$i = 0; i< pocet\_iteraci; i++$}{
	retezec = SHA256 (retezec)\;
    }
    citelna\_data = desifrujData(Data, retezec, IV)\;
    
    \caption{Princip vytvoøení hesla pro de¹ifrování pomocí 7z}\label{alg:7z_desifr}
\end{algorithm}

\chapter{Závìr}
Obsáhnout v¹echny mo¾nosti a~nastavení analyzovaných formátù je znaènì nároèný proces, který
ve vìt¹inì pøípadù ani nestojí za námahu. Dùvodem je nízký poèet dostupných nástrojù schopných tyto
hodnoty nastavit, co¾ platí hlavnì pro formát ZIP.

 Struktury jednotlivých formátù byly popsány tak, aby bylo mo¾né chybìjící nebo nejasné informace
dohledat ve specifikacích formátu a~nebylo nutné slo¾itì hledat, o~jaké hodnoty se jedná. Zde
je nutno podotknout, ¾e, jak ji¾ bylo zmínìno, struktura 7z souboru je hodnì komplexní a~promìnná.
Bohu¾el dokumentace tohoto formátu je znaènì nedostaèující a~je tedy nutné strávit hodnì èasu
studiem struktury, zdrojových kódù a~fóra vývojáøe pro získání dal¹ích a~detailnìj¹ích informací.

 Návrh roz¹íøení modulu pro ZIP by mìl z~vìt¹iny odpovídat tomu, jak bude roz¹íøení vypadat po jeho
implementaci. Také na základì prùzkumu v~tomto odvìtví by roz¹íøený modul mìl být napøed pøed
konkurencí. Nìkteré známé nástroje toti¾ mají podporu pouze pro WinZip AES a~PKWARE ¹ifrování
(John the Ripper) nebo momentálnì neposkytují funkcionalitu k~formátu .ZIP (oclHashcat).  

 U~modulu 7z se jedná spí¹ o~teoretický nástin, jak by mohl modul vypadat a~jak by
mohly jednotlivé èásti algoritmu fungovat. Nìkteré dùle¾ité informace toti¾ nejsou nikde detailnì
popsány. Hledání informací ve zdrojových kódech 7zip-u je díky absenci komentáøù a~vysoké
abstrakci kódu znaènì nároèné a~zdlouhavé. Návrh modulu bude tedy potøeba pravdìpodobnì
modifikovat na základì informací zji¹tìných bìhem implementace jednotlivých èástí modulu.

 Bìhem implementace bude zapotøebí vytvoøit dvì verze obou modulù. Jednu verzi bì¾ící pouze na
CPU a~druhou, která bude podporovat paralelní zpracování na GPU. V~návaznosti na implementaci
bude potøeba provést mìøení rychlosti a~srovnání s~dal¹ími nástroji. Podle výsledkù srovnání
jde odhadnout, jak moc optimální ná¹ modul je a~zda je potøeba jej upravit a~vyladit nebo
zda je v~rámci mo¾ností optimalizován.

%=========================================================================
