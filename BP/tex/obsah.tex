%=========================================================================
% (c) Michal Bidlo, Bohuslav Køena, 2008

\chapter{Úvod}
Ochrana a zabezpeèení soukromých a dùle¾itých informací je v dne¹ní dobì èasto se vyskytujícím
tématem na poli informaèních technologií. Je jedno jestli se bavíme o zabezpeèení dat pøi pøenosu
po síti nebo o zabezpeèení lokálnì ulo¾ených dat. Ka¾dý z nás asi zná situaci, kdy potøebuje
sdílet s nìkým informace, ale chce zajistit, ¾e je budou schopni pøeèíst pouze osoby, které jsou k
tomu urèeny.\\ 
\indent Toho lze dosáhnout ¹ifrováním informací. V dne¹ní dobì máme nezpoèet mo¾ností jak ¹ifrovat
informace. Výbìr pou¾itého ¹ifrovacího algoritmu má znaèný vliv na kvalitu zabezpeèení dat. Ov¹em
zvolení správného hesla má vliv je¹tì vìt¹í. Pokud pou¾ijete slabou ¹ifru a silné heslo ¹ance, ¾e
se k Va¹im datù dostane je o dost men¹í ne¾ kdy¾ to udìláte naopak.\\ 
\indent Èasto chceme sdílet nebo zabezpeèit více jak jeden soubor s informacemi. Obecnì se pro
spojení více souborù, rùzného typu, do jednoho celku pou¾ívají archivy. Jedním z nejroz¹íøenìj¹ích
typù souborových archivù jsou formáty .ZIP a .7z.\\
\indent V této práci se pøevá¾nì zabývám analýzou pou¾ívaných metod zabezpeèení a ¹ifrovacích
algoritmù u tìchto formátù a následnì získáváním hesel k takto zabezpeèeným souborùm. Výsledky
tìchto analýz jsou pou¾ity pro návrh roz¹iøujících modulù nástroje {\it Wrathion}. Práce se také
zabývá pøibli¾ením paralelismu a problémù s ním spojených a také úvedením do standardu a
frameworku OpenCL.

\chapter{Úvod do paralelismu}
Dne¹ním trendem ve vývoji architektur pro výpoèetní zaøízení je umo¾nìní paralelního provádìní úloh.
Jedná se o architektury otevírající dveøe k znatelnému zvý¹ení výkonu u zaøízeních na nich
postavených. Dnes ji¾ pova¾ujeme za normální, ¾e máme více--jádrové procesory (CPU), které
podporují paralelní zpracování. Ov¹em jedním z hlavních pøedstavitelù toho trendu jsou grafické 
výpoèetní jednotky (GPU). Existence tìchto typù zaøízení ús»í v potøebu mít prostøedky jak s tìmito
zaøízeními komunikovat a programovat je.\\
\indent U paralelních aplikací je na¹í nejvìt¹í prioritou efektivnost vyu¾ití zdrojù. Dùvodem je
vysoká poøizovací cena a èasto i vysoké provozní náklady. Dal¹ím dùvodem je také nároènost aplikací
na nich bì¾ících. Ty jsou ve vìt¹inì pøípadù èasovì velmi nároèné. Návrh i programování aplikace
vyu¾ívající paralelismù mù¾e být znaènì nároèné. Je zde velký rozdíl v programovacích technikách.
Programování paralelních aplikací pro CPU vychází ze za¾itých standardù pou¾ívaných pro vývoj
klasických aplikací. Oproti tomu programování GPU a jiných specializovanìj¹ích zaøízení se od tìchto
standardù velmi li¹í. Napøíklad vytváøení obecnì pou¾itelné aplikace urèené pro bìh na GPU je
nároèné hlavnì z hlediska odli¹ného pamì»ovému modelu a jinou ¹kálou funkcí pro práci s ní. GPU
ve znaèné míøe vyu¾ívá operace pro práci s vektory. Nejvìt¹ím problémem spojeným s programováním
tìchto zaøízení je ¹kála rùzných pou¾ívaných architektur. Faktem je, ¾e v¹echny modely pro práci se
zaøízeními (pamì»ový model, model provádìní atd.) se mohou mìnit a to v závislosti na platformì,
výrobci èi pou¾itím hardwaru.\\
\indent Takovýto vývoj obecnì pou¾itelných aplikací by byl nereálný, proto¾e bychom museli
aplikaci vyvynout ve desítkách ne--li stovkách verzí pro jednotlivá konkrétní zaøízení, na kterých
bychom chtìli aplikaci provozovat. Proto se vyskytla potøeba vytvoøit univerzální rozhraní, jen¾ by
nad specifickými pøístupy k programování jednotlivých zaøízení vytvoøilo univerzální programovací
vrstvu, její¾ instrukce by následnì byly interpretovány do instrukèní sady specifického zaøízení.
Takovýmto rozhraním je napø.: CUDA nebo OpenCL.

\section{OpenCL}
Jedná se o otevøený nezpoplatnìný standard slou¾ící k zjednodu¹ení a zefektivnìní programování
paralelních aplikací. OpenCL vyu¾ívá rozhraní, které pracuje na velmi nízké úrovni, tedy skoro na
úrovni samotných fyzických souèástek, èím¾ dosahuje vysoké efektivity. Nad tímto rozhraním následnì
vytváøí vrstvu pro výpoèty, jen¾ obsahuje pracovní prostøedky nezávislé na platformì. Hlavní síla
OpenCL je zkombinování paralelních výpoètù aplikace na GPU se zøetìzeným rendrováním grafických
prvkù.\\
Standard:
\begin{itemize}
    \item podporuje datovì i úlohovì zalo¾ené paralelní programovací modely
    \item definuje konzistentní numerické po¾adavky vycházející z IEEE 754
    \item definuje konfiguraèní profil pro pøenosná zaøízení a vestavìné systémy
    \item zaji¹»uje efektivní souèinnost s OpenGL, OpenGL SE a dal¹ími grafickými rozhraními
\end{itemize}

Nejedná se pouze o standard pro psaní paralelních aplikací, ale i o stejnojmenný framework, který
je na tomto standardu postaven. Framework OpenCL zahrnuje programovací jazyky, rozhraní pro
programování aplikací (API), knihovny a runtimový systém pro ulehèení vývoje.
\subsection{Architektura OpenCL}
Struktura OpenCL architektury lze popsat hieararchyckým modelem následovnì:
\begin{itemize}
    \item Model platformy
    \item Model provedení
    \item Model pamìti
    \item Programovací model
\end{itemize}

\subsubsection{Model platformy}
Tento model se skládá z hostitele a jednoho nebo více OpenCL zaøízení, která je rozdìleno na jedno
nebo více výpoèetních jednotek, které jsou dále dìleny na jeden nebo více výpoèetních prvkù.
Na jednotlivých prvcích se pak provádí výpoèetní operace.\\
\indent Rozdìlení na hostitele a zaøízení vy¾aduje implementovat aplikaci pro obì èásti. Tedy
vytvoøit kód pro hostitele a pro kernel zaøízení. Vezmeme--li si jako pøíklad standardní poèítaè
tak hostitel je CPU a zaøízení je GPU, pøípadnì více GPU.\\

---------------- sem prijde obrazek platformy --------------------------\\
\subsubsection{Model provedení}
Jak ji¾ bylo zmínìno aplikace se dìlí na dvì èásti. Zde hovoøíme o kernelech a o hostitelovì
programu, pøièem¾ kernel je ten, kdo provádí výpoèty. Tato ``práce'' je provádìna pomocí
pracovních polo¾ek ({\it work-item}) jen¾ mù¾eme sdru¾ovat do pracovních skupin ({\it
work-group}).\\
\indent Hostitel má za úkol spravovat kontext aplikace a na základì nìho nastavovat prostøedí, ve
kterém bude kernel provádìt operace. V prostøedí musíme specifikovat a nastavit tyto polo¾ky:
\begin{itemize}
    \item Zaøízení
    \item Objekty kernelu
    \item Objekty programu
    \item Objekty pamìti
\end{itemize}

\indent Hostitel se zaøízením komunikuje pomocí front pøíkazù, do nich¾ se pøíkazy rozøadí podle
typu operace. Jednotlivé pøíkazy ve frontì se provádí relativnì k ostatním pøíkazùm. Poøadí
provádìní je definováno tìmito modely:
\begin{itemize}
    \item {\it In-order} -- pøíkazy se provádí a mají efekt tak, jak do fronty pøisly
    \item {\it Out-of-order} -- poøadí provedení pøíkazù je omezeno pouze explicitnì uvedenými
	    synchronizaèními body nebo explicitnì definovanými závislostmi na událostech
\end{itemize}

\subsubsection{Model pamìti}
Práce s pamìtí v OpenCL se znaènì li¹í od klasického pøístupu, který známe ze standardních
aplikací urèených pro bìh pouze na CPU. Pamì»ový model OpenCL popisuje obsah, strukturu a chování
pamìti pou¾ívané v platformì vytvoøené tímto frameworkem.
\indent Pro ka¾dou aplikaci je tøeba pøesnì definovat jak budou jednotlivé pamìti v pamìti vypadat.
Model dìlíme na ètyøi èásti:
\begin{itemize}
    \item {\it Oblasti pamìti} -- definuje se kterými oblastmi pamìti hostitel a zaøízení ve
	stejném kontextu mohou pracovat
    \item {\it Objekty pamìti} -- jsou definované v OpenCL API, o správu se stará hostitel i
	zaøízení
    \item {\it Sdílenou virtuální pamì»} -- jedná se o virtuální adresový prostor pøístupný obìma
	èástem aplikace
    \item {\it Model konzistence} -- definuje pravidla pro oblasti pamìti, které jsou pou¾ívané
	více jednotkami zaráz a zaruèuje, ¾e je dodr¾eno poøadí operací s pamìtí a ¾e jsou data po
	celou dobu validní. Takté¾ definuje synchronizaci nad tìmito oblastmi.
\end{itemize}

\indent Pro nás je nejdùle¾itìj¹í pochopit jak je pamì» strukturována a jak na sebe navazují
jednotlivé oblast to je nejlépe patrné z obrázku \#\#\#. Popis struktury:
\begin{itemize}
    \item Pamì» hostitele (RAM apod.)
    \item Pamì» zaøízení
    \begin{itemize}
	\item {\it Globální pamì»} -- oblast je pøístupná pro ètení i zápis v¹em jednotkám v
	    kontextu nezávisle na zaøízení
	\item {\it Pamì» konstant} -- pøed zahájením výpoètu je alokovaná a inicializována
	    hostitelem a v prùbìhu výpoètu se tato oblast nemìní výpoètu
	\item {\it Lokální pamì»} -- oblast je pøístupná v¹em pracovním polo¾kám ve
	    stejné pracovní skupinì
	\item {\it Soukromá pamì»} -- oblast je pøístupná pouze jedné pracovní polo¾ce 
    \end{itemize}
\end{itemize}
------- obrazek struktury pameti ------------------------\\
\subsubsection{Programovací model}
Tento model lze také nazvat jako OpenCL Framework. Framework se skládá ze tøech komponentù. Zde za
zmínkud stojí OpenCL kompilátor. Ten podporuje pokroèilý jazyk SPIR-V a jazyk OpenCL C. Dal¹í
jazyky mohou být podporovány nìkterými implementacemi kompilátoru.


\chapter{Nástroj Wrathion}
Jedná se o nástroj vytvoøený Janem Shmiedem v roce 2014 v rámci jeho diplomové
práci\cite{Schmied}. Nástroj byl vytvoøen pro pou¾ití v projektu {\it Moderní prostøedky pro 
boj s kybernetickou kriminalitou na Internetu nové generace, MV, VG20102015022}.\\
\section{Hlavní èásti Wrathionu}
Nástroj slou¾í ke obnovování hesel pomocí brute-force útokù na tato hesla. Skládá se za ze tøí
èástí:
\begin{itemize}
	\item Jádra
	\item Modulù
	\item Aplikace
\end{itemize}

Nástroj je z pohledu obnovování hesel rozdìlen na dvì stì¾ejní èásti:
\subsection{Generátory hesel}
První jsou generátory hesel pro útoky. Jednáse se esenciální funkcionalitu. Bez
vygenerovaných hesel nemù¾eme na útoky vùbec myslet. V nástroji jsou momentálnì implementovány tøi
typ generátorù:
\begin{itemize}
    \item {\it Brute-force} -- postupnì generuje v¹echny mo¾né permutace ze zadaných znakù
    \item {\it Rule-based} -- velmi podobný pøedchozí variantì ov¹em umo¾òuje specifikovat rùzná
	podpùrná pravidla pro generování hesel. Napøíklad, ¾e má být první písmeno velké, druhé má
	být 'a' a ¾e poslední 2 znaky jsou èíslice. Toto umo¾òuje zù¾ení poètu permutací a tedy
	sni¾uje èas potøebný k vygenerování v¹ech jejich variant (tento typ generátoru je vyvýjen v
	rámci jiné bakaláøské  práce).
    \item {\it Unicode} -- jedná o jistou formu rule-based generátoru ov¹em v tomto pøípadì je
	pouze nastavena vstupní abeceda na v¹echny Unicode znaky a znich jsou generovány mo¾né
	permutace hesel
    \item {\it Dictionary} -- slovníkový generátor, vyu¾ívá externí soubory s èasto pou¾ívanými
	hesly
\end{itemize}

Nejèastìji pou¾ívaným generátor je brute-force, který je ov¹em výpoèetnì nároèný. Jedná se v¹ak
o snadno paralelizovatelný, proto je pøíhodnì implementován i jako kernel bì¾ící na GPU.
\subsection{Crackery}
Druhou èástí jsou samotné crackery, které se dìlí podle toho, kdo provádí generování hesel a
kdo provádí porovnávání hesel:
\subsubsection{CPU cracker}
Zde se standardnì spustí ji¾ pøedkompilovaný cracker napsaný v C++. Není zde ¾ádný vìt¹í problém s
generováním ani následným ovìøováním hesel. Ov¹em výpoèetní síla u paralelizovatelných algoritmù
není CPU ani zdaleka tak vysoká jako na GPU. Proto, pokud je to mo¾né, volíme druhou variantu
crackeru.
------ diagram CPU crackeru

\subsubsection{GPU cracker}
Cracker mù¾e pracovat ve dvouch re¾imech. Prvním je, ¾e hesla generujeme na CPU a pak je posíláme
do pamìti GPU, kde jsou crackerem zpracována. To má ov¹em velkou nevýhodu v tom, ¾e musíme poøád
posílat data z pamìti hostitele (CPU) do privátní pamìti výpoèetního prvku (vypoèetní jednotka
na GPU).\\
------ diagram GPU crackeru s generovanim na CPU\\
\indent Druhou a efektivnìj¹í mo¾ností je generovat hesla pøímo na GPU do privátních pamìtí èím
minimalizujeme mno¾ství dat, které musí putovat od hostitele k zaøízení, èím¾ sní¾íme výslednou
prodlevu výpoètù.\\
------ diagram GPU crackeru s generovanim na GPU\\
\indent V obou pøípadech je nutné pøed zahájením jakýchkoliv operací GPU inicializovat OpenCL
systém. Tedy vytvoøit kontext, fronty pøíkazù, naèíst se a pøelo¾it po¾adovaný kernel a a¾ poté
nahrát nebo vygenerovat data do/na GPU.

\subsection{Moduly}
Nástroj je navr¾en s velkým dùrazem na modularitu. V souèasné dobì obsahuje pouze tøi moduly.
Roz¹íøení poètu implementovaných modulù má za úkol nejen tato práce, ale dvì dal¹í práce vypsané v
leto¹ním roce.

\subsubsection{Modul ZIP}
V této práci nás nejvíce zajímá modul ZIP. Ten v pùvodním návrhu obsahuje pouze ¹ifrování
obnovování hesel z archívù ¹ifrovaných algoritmy PKZIP, AES-128, AES-192, AES-256, co¾ zanechává
prostor pro implementaci dal¹í, formátem {\it .ZIP}, podporovaných metod. Zajímavostí je, ¾e tento modul
byl schopný v dobì svého vzniku obnovit heslo ¹ifrovaných {\it .DOCX} souborù, av¹ak tento
nedostatek u zabezpeèení formátu {\it .DOCX} byl pozdìji odstranìn a tento modul ji¾ tedy není
schopen heslo, u souborù vytvoøených po zmínìn aktualizaci, obnovit.

\subsubsection{Modul DOC}
Dal¹í modul pracuje s formátem {\it .DOC}, který byl pokládán za základní formát aplikace MS Word z
balíku MS Office. Tento formát byl s pøíchodem MS Office 2007 nahrazen formátem {\it .DOCX}. Nástroj ve své
pùvodní podobì obsahuje pouze podporu pro {\it .DOC} formátu. Tvorba modulù pro novìj¹í formát
{\it .DOCX} spolu s formáty pou¾ívanými v jiných aplikacích balíku MS Office jsou tématem
jedné, soubì¾nì s touto prací spracovávané, bakaláøské práce.

\subsubsection{Modul PDF}
Prozatím posledním ji¾ vytvoøeným modulem je modul pracující s formátem {\it .pdf}. Zde jsou ji¾
implementovány bezpeènostní revize 1-5. Nástroj poèítá i s implementací revize 6 ta ale není
nikterak urgentní, proto¾e souborù pou¾ívajících revizí 5 a 6 je velice málo.


\chapter{Popis formátù .ZIP a .7z}
\section{Formát .ZIP}
Jedná se o jeden z prvních formátù souborových archivù, který podporoval kompresy dat. V roce 1989
vytvoøil Phil Katz program PKZIP v rámci nìho¾ byl pøedstaven samotnýho nový formát .ZIP.
Specifikace formátu .ZIP byla publikován pod veøejnou doménou. Tímto krokem pomohl
formátu se stát celosvìtovým otevøeným standardem\cite{PKWARE:2015}. V roce 2015 byl formát, ve své
specifikaci 6.3.3 z roku 2012, pøijat Mezinárodní orgranizací pro normalizaci (ISO) a Mezinárodní
elektrotechnickou komísí (IEC) jako¾to standard definovaný dokumentem ISO/IEC
21320-1:2015\cite{ISOIEC:2015}.\\
\indent Formát podporuje velké mno¾ství rùzný komprimaèních algoritmù: Store(bez komprese),
UnShrinking, Expanding, Imploding, Tokenizing, Deflating, Enhanced Deflating, BZIP2, LZMA, WavPack
a PPMd\cite{PKWARE:2014}.\\ 
\indent Obdobnì je to i s podporou rùzných ¹ifrovacích algoritmù:
\begin{itemize}
    \item {\it PKWARE ¹ifrování} -- prvotní ¹ifrování 
    \item {\it DES, 3DES(112-bit and 168-bit)} -- podporováno od verze 5.0 z roku 2002
    \item {\it RC2 (40-bit, 64-bit a 168-bit)} -- podporováno od verze 5.0 z roku 2002
    \item {\it RC4 (40-bit, 64-bit a 168-bit)} -- podporováno od verze 5.0 z roku 2002
    \item {\it AES (128-bit, 192-bit a 256-bit)} -- podporováno od verze 5.2 z roku 2003
\end{itemize}

\indent Nastává zde ale problém. Je prakticky nemo¾né najít nástroje umo¾òující vytvoøení archívù
se ¹ifrováním DES, RC2 a RC4. Z toho tedy plyne, ¾e pravdìpodobnost výskytu archívù ¹ifrovaných
tìmito metodami je minimální respektive témìø nulová.

\subsection{Struktura souboru}
Soubor se skládá z kombinace rùzných typù hlavièek s pevnou délkou, dat souborù v komprimované /
nekomprimované a ¹ifrované / ne¹ifrované podobì a ve vìt¹inì pøípadù i popisovaè dat o velikosti 12
bajtù. Konkrétní struktura je na obrazku XY.\\
-------- obrazek skladani hlavicek
\indent Hlavièka, roz¹íøená o metadata, ka¾dého souboru pak musí být obsa¾ena v nìkteré ze "Central
Directory" sekcí zapoèaté pomocí vlo¾ení {\it Central Directory Header} a ukonèené dal¹í buïto dal¹í
hlavièkou nebo pomocí {\it End of Central Directory Record}. Soubor musí v¾dy obsahovat alespoò
jednu {\it Central Directory Header}. Jednotlivé sekce reprezentují adresáøe a hlavièky souborù
reprezentují pùvodní organizaci souborù pøed vytvoøením archívu.\\

\indent Pro tuto práci je ale nejdùle¾itìj¹í hlavièka {\it Encryption Header} nacházející se za
hlavièkou souboru. Proto¾e ka¾dý soubor archívu mù¾e být ¹ifrován jinou metodou a s jiný klíèem, tak
musíme hlavièku ¹ifrování vlo¾it pøed samotná data. Z teto hlavicky musim ziskat informace z polozky
{\it AlgID}, v ní¾ nás zajímají hodnoty 0x6609 a 0x6603 (3DES 112 a 168). Dal¹í pro nás dùle¾itou polo¾kou
jsou {\it Flags}


\section{Formát .7z}
Vznik tohoto formátu se datuje do roku 1999 a jeho autorem je Igor Pavlov. Stejnì tak jako aplikace
7-zip a nástrojù spojených s tímto formátem. Formát se proslavil hlavnì svojí otevøeností a
modulární strukturou. Ta umo¾òuje skládání libovolných kompresní, konverzních a ¹ifrovacích metod.\\

\indent Jako výchozí kompresní metoda se bere LZMA. Výhody této metody jsou:
\begin{itemize}
    \item Vysoký kompresní koeficient
    \item Promìnná velikost slovníku
    \item Malé nároky na pamì» pøi dekompresi
    \item Podpora zpracování pomocí multi-threading a hyper-threading
\end{itemize}
\subsection{Struktura souboru}
\section{Srovnání}


\section{Návrh modulu}

\section{Závìr}





%=========================================================================
